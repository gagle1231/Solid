{"id":"node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js","dependencies":[{"name":"C:\\Users\\82108\\solid-demo-app\\node_modules\\jsonld-streaming-parser\\lib\\containerhandler\\ContainerHandlerLanguage.js.map","includedInParent":true,"mtime":1690072859917},{"name":"C:\\Users\\82108\\solid-demo-app\\package.json","includedInParent":true,"mtime":1691304712566},{"name":"C:\\Users\\82108\\solid-demo-app\\node_modules\\jsonld-streaming-parser\\package.json","includedInParent":true,"mtime":1690072859902},{"name":"jsonld-context-parser","loc":{"line":4,"column":40,"index":160},"parent":"C:\\Users\\82108\\solid-demo-app\\node_modules\\jsonld-streaming-parser\\lib\\containerhandler\\ContainerHandlerLanguage.js","resolved":"C:\\Users\\82108\\solid-demo-app\\node_modules\\jsonld-context-parser\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerLanguage = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerLanguage {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        const language = await util.getContainerKey(keys[depth], keys, depth);\n        if (Array.isArray(value)) {\n            // No type-checking needed, will be handled on each value when this handler is called recursively.\n            value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n        }\n        else {\n            if (typeof value !== 'string') {\n                throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n            }\n            value = { '@value': value, '@language': language };\n        }\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerLanguage = ContainerHandlerLanguage;\n"},"sourceMaps":{"js":{"version":3,"file":"ContainerHandlerLanguage.js","sourceRoot":"","sources":["ContainerHandlerLanguage.ts"],"names":[],"mappings":";;;AAAA,iEAA8D;AAK9D;;;;;GAKG;AACH,MAAa,wBAAwB;IAE5B,mBAAmB;QACxB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,UAA2C,EAAE,cAA8B,EAAE,IAAU,EACvF,IAAc,EAAE,KAAU,EAAE,KAAa;QAE3D,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAEtE,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxB,kGAAkG;YAClG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;SAClF;aAAM;YACL,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC7B,MAAM,IAAI,kCAAU,CAClB,wCAAwC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,wBAAwB,EACrF,mCAAW,CAAC,0BAA0B,CAAC,CAAC;aAC3C;YACD,KAAK,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC;SACpD;QACD,MAAM,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;QAE3F,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,iCAAiC;IAC/E,CAAC;CAEF;AA3BD,4DA2BC","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IContainerHandler} from \"./IContainerHandler\";\n\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nexport class ContainerHandlerLanguage implements IContainerHandler {\n\n  public canCombineWithGraph(): boolean {\n    return false;\n  }\n\n  public async handle(containers: { [typeName: string]: boolean }, parsingContext: ParsingContext, util: Util,\n                      keys: string[], value: any, depth: number)\n    : Promise<void> {\n    const language = await util.getContainerKey(keys[depth], keys, depth);\n\n    if (Array.isArray(value)) {\n      // No type-checking needed, will be handled on each value when this handler is called recursively.\n      value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n    } else {\n      if (typeof value !== 'string') {\n        throw new ErrorCoded(\n          `Got invalid language map value, got '${JSON.stringify(value)}', but expected string`,\n          ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n      }\n      value = { '@value': value, '@language': language };\n    }\n    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n\n    parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n  }\n\n}\n"]}},"error":null,"hash":"64a88d487aaa55175c27f3969f6ac484","cacheData":{"env":{}}}